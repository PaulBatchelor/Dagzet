@2025-08-17#logzet
@14:33 Re-aquainting myself with this repo, hello logzet #logzet #timelog:00:05:25
I have this logging format that I have been using
for the past year or so. It's sort of adhoc, but
I have a few parsers for it. I'm hoping to make
a more established parser for it here. Similar
to dagzet, it'll parse files and return SQLite
code to produce relational databases.
---
I'm hoping to begin by adding a new aux binary
called logzet. I'd like to install it by default
with dagzet.
---
Well, that was pretty painless. Now for the harder
part, setting up the parser.

@14:42 Planning out the parser #timelog:00:17:31
For the most part, parsing is done line-by-line.
---
The start of the line determines what the line is
going to be.
---
An '@' at the start of the line
signifies the start of a block. What follows the @ determines
what kind of block it will be. For now, there are really two
types of blocks: blocks that indicate a date, and ones that
indicate a time.
---
Date Blocks: The format is YYYY-MM-DD?(#(TEXT)) (like my pseudo-regex?).
In the program, this thing sets the current day of the program.
The hashtag adds a tag for the day.
---
Time blocks: HH:MM (TITLE). This creates a log entry at a particular
time. A day block should be made before adding time. Everything following
the the timestamp (plus whitespace) is the title.
---
Titles in the time blocks can have hashtags. These do not get included in the
the actual title name, and should be automatically removed.


@15:20 continued parsing plans (describing the parser) #timelog:00:14:54
Lines that start with "#!" are logzet commands. Typically,
these come right after the line that starts a block,
but I don't think that needs to be the case.
---
The only command that is used currently is "dz", which
links the current log entry to a particular dagzet node.
---
A line that starts with '---', and nothing else, is considered
a break. Typically, I use these to break things into
paragraphs.
---
A line that starts with "===" begins a pre-formatted block, usually
used for code blocks. It preserve all line breaks and spaces until
it finds another lines starting with "===".
---
I think that's most of it?
---
OH! right. Empty lines are ignored.

@15:46 attack plan #timelog:00:31:06
I'm thinking I may have this be a two-pass parsing process.
The first pass tokenizes things by line, the second pass
parses these tokens to build up a more meaningful representation
of the data.
---
Tokenization is pretty straight forward. Use an enum.
Parse text line by line.
---
Plain text content in a block (anything that isn't a block
or metablock), can be stored line by line and merged later.
pre-formatted block starts change the behavior of the line
parser. Once a block starts, every line parsed after that
points becomes a preformatted line until it finds another
corresponding "===", which turns it off.
---
For logs, log entries are grouped by dates, and dates
can be grouped by category.
---
Claude has come up with suggestions for what to call
these things: A "Session" describes a combination of
a "Date" and an optional "Context". A Session contains
a group of log entries associated with that context.
---
Since dagzet support is also going to be wanted here,
there should be something that shows a list of
related nodes (represented as paths).
---
An Entry consists of a list of content chunks. Maybe
these are just called "blocks" (claude suggests this).
I want this log format to also be generalized in
terms of blocks, but that may be overgeneralizing.

@16:26 working out the initial data structures #timelog:00:47:38
I'm just gonna put them in the one file.
---
I'm thinking about source maps. I think the best way to
express this is as a generic struct that wraps
an inner type.
---
Got some initial structs down. Now, I want to create
some From traits for the lower-level statements.

@17:45 some initial From traits #timelog:00:11:12

@19:22 initial boilerplate: got "break" parsed #timelog:00:20:25

@19:43 attempting regex matching for Time #timelog:00:20:16
Ran out of time. Gotta get home.

@2025-08-18#logzet another hub session

@19:31 resuming where I left off, matches for Time #timelog:00:49:57
I got the basic regex working! now I need to add in
hashtags.

@20:21 Now a similar thing for Date #timelog:00:59:41
This will have a title. Might as well have hashtags?
This could be a generic.
---
Got the "context" hashtag working. Now getting the regular tags working?
---
Working!

@21:22 interlude... fix cargo clippy warnings #timelog:00:01:45

@21:25 get commands working #timelog:00:11:21

@22:07 next steps #timelog:00:10:12
There needs to be something that takes a list of
strings, and turns it into a corresponding vector
of Statements. This should be able to handle
comments as well as blocks.
---
A vector of statements, should also be able to be parsed
and turned into a set of sesssions.
---
Entries and sessions should be sorted. Use a BTreeSet?
Or possibly, it might be just good enough to use parsing
order?
---
Figure out best way to convert data into SQLite tables.
Figure out table schema, then make a bunch of insert
statements.
---
Dagzet commands. Get that behavior in.

@2025-08-19#logzet working at home, PLG, Brooklyn
@20:31 Let's see if I can plan out how Statements turn into Sessions #timelog:00:25:40
I've built myself function. Vector of Statements go in,
Vector of Sessions comes out.
---
I want the output list to be in chronological order.
I'm thinking order could be preservered internally with either
a BTreeMap or a BTreeSet, then converted to a Vec at the last minute.
---
The logic would work by keeping track of the last Date (year, month, day, context).
I believe that by default, the BTree will sort things in order that they appear
in the struct. subsequent statements, would then get processed and inserted into
that active slot.
---
Time entries, like Date entries, should be in sorted order as well. Having a BTree
would be nice, but the struct at the end should simplified to be a Vec somehow.
So, I guess there are some intermediates.
---
Two nested BTreeMaps. The Outer Map is for Dates, and each entry in that map
points to an Inner BTreeMap for Time Entries.
---
Date/Time structs need to be split up more because they have
junk in it like titles and tags. Maybe TimeKey and DateKey.
---
Build BTreeMap types for Session and Entry called SessionMap
and EntryMap. EntryMap is an alias for BTreeMap<TimeKey,Block>.
SessionMap is an alias for BTreeMap<DateKey,EntryMap>. Once it
is all populated, they can get converted to regular list of Sessions
which contain a regular list of entries.

@22:02 some initial refactoring to get DateKey and TimeKey #timelog:00:27:12
I also got the initial BTreeMaps set up as well. It
could be refactored further I think, but this is
good enough.

@22:30 First parse test: can days out of order be put in order? #timelog:00:39:25

@2025-08-20#logzet Brooklyn
@10:46 examining the existing SQLite code I have. Can I re-use it? #timelog:00:22:29
My SQLite generator code may be flexible enough to accomodate
the needs for my logs table.
---
My SQLite table code might just be flexible enough.
---
Reaquainting myself with the schemas now.
---
Right. I seem to have two parts to my SQLite interface.
There's a "Row", which contains data for a row. This
seems to exist to produce a comma separated set of values
in a specified order. There's a "Table", an opaque value which
gets dynamically constructed. This has the parameters as well
as their names. The Table and Row work together to create
insert statements.
---
Working with this interface, it seems like the path of
least resistance is to convert a list of Sessions
into a list of Rows that represent the SQLite table
representation. From there, the SQLite traits
can be built out.
---
I get the feeling that with a little bit more
work, I could maybe remove the intermediate
"Row" data format, but in many ways this is
simpler and less work since this is already
written out for me.

@11:18 building out a Row, an initial Session to Rows conversion #timelog:00:48:00
There are two kinds of rows actually, a "dayblurb" for the
day with a blurb (does this need to be there if blurb is none?)
and the entries themselves.
---
Working on the initial dayblurb because it's slightly less
work upfront.
---
Now to get some entries populated.

@12:38 continue to populate some entries for the test #timelog:00:18:07
I think I have the initial test set up. Now to implement
the actual code to make the entries

@12:56 implement the actual code to generate the entries #timelog:00:23:57
One thing that I've started doing more is having a single timelog
broken up into blocks. The current SQLite table doesn't
actually support blocks, that's something that gets handled
by the renderer. Moving forward, it would be better to have
this be modelled with the data.
---
For now, only comments will be supported, no preformatted stuff.
I never actually got around to implementing multi-comments
in my ad-hoc implementation. So, this'll mean breaking compatibility
eventually.
---
Tests seem to pass. Does that mean it works?

@13:41 more parser work for converting Statements into Sessions: grouping #timelog:01:03:23
Right, I'm going to work on getting the core logging components
figured out. That's going to be a date header, setting times,
and appending blocks to those times.
---
Going to make it really brittle right now. Overwriting
dates/times will be possible. I will harden later.
What I want to do is make sure the most bare minimum input
yields the correct output. At that point, the implementation
can start being more end to end.
---
dagzet commands will follow up shortly. I think I am going
to break backwards compatibility for this. I really
want more granular support for multiple blocks, and I want
to make it possible to link nodes to particular blocks
instead of just timestamps.
---
At this point, I'm going to assume the parsing is working
correctly? I think the observed behavior for this test
is that grouping is happening as expected for entries.
---
I didn't think about the line breaking logic. Line breaks
are treated as spaces. Empty lines are ignored.
---
Goodness time got away from me.

@15:04 I need to work out line breaking logic for this parser #timelog:00:33:40
Working backwards, I'm hoping this can be as simple as as
joining a vector of strings together.

@18:01 back to getting the grouping right #timelog:00:07:01
The line breaks work, I just didn't factor in the grouping.

@18:12 looking into dagzet logic #timelog:00:37:28
I think the way I did this before was a bit of a hack.
I believe what it did was was make the node a hashtag
with the prefix "dz:". I'd then have code that was able
to search for these nodes associated with messages
and stitch them up.
---
What I want is a more dedicated structure for the job.
Something that actually shows the relationship between
items.
---
Previously, I was only attaching nodes to entries. I'd
like to extend that to be with blocks inside an entry
as well. A more sophisticated command language would
be nice too, but I can think on that one later. Just
full paths and '$' should be good enough.
---
I could probably make an ID system work. The id would
map to a list of node paths. Somehow, this could be something
that could be query-able in a SQL join operation.
---
A potential structure could be an entity list. Anything
that gets made gets added to this list.
---
Any time you'd call the dagzet command, you'd be appending
it to the last entity item on the list.
---
This could be a helpful item in general for things like
source maps, so, I'm included to see how feasible it
would be to construct such a thing.

@18:59 entity list investigations, might need to go full ECS. Is this ECS? #timelog:00:23:48
For starters, get the old way working, which is
the ability to link to the entry. Build an entity
component list but only add entries.
---
Okay. So this might be a non-trivial refactor. I think
I need to reverse the thining. The entity list owns all
the components, and the struct just references it. This
is how an entity component system would work.

@20:12 let's try that entity list #timelog:01:49:07
I'm going timebox this, get some initial scaffolding in.
---
Huh, there's really just three entity types at the end of
the day: Sessions, Entries, and Blocks. Doesn't seem
so bad...
---
To try things out, I'm going to work on making all Blocks references,
and maintaing a list of blocks externally. This should get
the lifetime annotations correct. From there, I can more
generalize this list of blocks into a pool.
---
Okay, it started getting a little hairy there. I tried getting
blocks working for output data structure. But what if it was
for the intermediate data structure (BlockData)? This could
potentially be an internal refactor, might be less damage.
---
It has been an hour. I'm still running into similar borrow
checker woes. Once again, this feels like a dead end.
---
We could try fake pointers and a block arena.
---
Well, the block list works! A good proof of concept.
The way to extend this would be to turn this into
an entity Enum.
---
Okay, I made it a more generic list. It works, but I'm already
seeing the issues of indirection. Once more types get introduced,
everything just becomes vectors of pointers. Sigh.
---
Final thoughts: session "map" needs to be taken into another function
I think. Entity list might another intermediate step. commands might
be a part of the entity list? Statements -> Entities -> Entities + Maps with pointers -> Sessions
data struct (no references or entities), other linked metadata.

@2025-08-21 Brooklyn
@12:06 Back to solving the entity list problem, first restating the problem #timelog:00:13:54
I am opting for a different structure than what currently exists.
The restructuring is going to be needed because it will make it
easier to tie content into dagzet.
---
The restructuring involves building an entity list, where every
possible type of item a log can make lives. Currently that's
Session (a day plus context), Entry (a timestamped log entry in a Session),
and a Block (something attached to an entry, usually text).
The existing structure (a struct outling the tree-structure hierarchy
of the session->entry->block relationships), would be refactored to
link to references from the entity list.
---
The reason why this way is ideal: it would allow building structures
that can easily link entities (referenced by an entity ID) to
groups of nodes. I want to extend the functionality of this linking
system beyond the original implementation I had to make it possible
to not only link to entries, but individual blocks as well.
---
The trouble is, how do we get this to work in such a way that
the borrow checker likes this. Right now, I am testing things
out by making blocks tracked externally. I managed to get fake
pointers working, but this is subpar because types will go away
with that approach, it's all just usizes.
---
I want to try and separate out the construction of the intermediate
data format, which I use to sort out the timestamps for sessions
and entries. Maybe with the right encapsulation I can please the
borrow checker? It's mostly been mutability issues. My lifetime
annotations have been no problem.

@12:23 pulling out sessionmap #timelog:00:07:26
This actually is helpful because it builds an abstraction
barrier of immutability. This new function returns a session
map and an entity list, both of which are immutable by the
time they leave the function. In a way, the Rust Compiler
is forcing us to build these abstractions. Probably a good
thing?

@12:34 now we fight the borrow checker. get blocks to be references #timelog:00:12:19
I get the feeling there might be a trick to this.
---
Here come the lifetime annotations.
---
Okay, the red squigglys are here. The problem has to do with
the way blocks are getting populated with lines. There seems
to be too many "access lines". The way parsing happens is,
text lines are always appended to the last created block.
The way this block is being accessed is through the last
created entity, but this only has a read-only reference.
This should probably be only done via the entity list.
---
Well, I commented out some things. It builds, but some
tests fail. As expected.

@13:11 trying to build an EntityListBuilder #timelog:00:35:41
This will be an interface that can populate a list of entities,
and at the end, I can return a immutable reference
to the list built. Should hopefully encapsulate some of the
mutabiliy issues
---
all write operations will be done through this
interface, instead of indirectly through the
last created entity. It's already assumed that
the last block made will be tied to the last
entity.
---
Sure enough, the moment I add things that return references,
I run into lifetime issues. I think I might
need to encapsulate the session map.
---
I have encapsulated the session map, which hopefully means
later I can move some logic inside the struct methods.
I've added some TODOs. In the meantime, gotta go.

@2025-08-22#logzet Brooklyn, PLG
@11:20 continued work on EntityListBuilder #timelog:01:31:57
I feel like I'm on the right path with encapsulation.
This seems to please the borrow checker.
---
...except some tests aren't passing. I thought I got
that working yesterday. Hmm...
---
looks like the grouping logic is broken.
---
right, I didn't actually implement the methods
for appending stuff to blocks and creating
new blocks.
---
Running into lifetime issues trying to append
the reference to the block to the entry.
---
I'm wondering if I need to group the session
map and the entity list into a struct.
---
I've merged the two things into a struct,
and I'm still getting lifetime issues.
---
There are too many mutable sources. the session
map and entity list can't both be mutable.
---
Can we build a session map, with references, from a read-only
entity list?
---
Or maybe, there's a sort of thing where we use a builder
pattern that appends items to the session map, but the
write is encapsulated in a method.
---
Yeah, that's not going to work either.
---
I'm trying the Statements -> Entities -> SessionData -> Session route,
where the new thing is explicitly making the entities,
THEN making the session data.
---
I'm going back a bit further now. The entity list initial
attempt was flawed from the start.

@12:57 Make entity list an initial intermediate format. NEVERMIND. #timelog:00:29:57
Blow up more old entity list
---
Now to think about this entity list a bit.
---
Entities are something inbetween statements
and the full-on data representations. No
nesting relationships are produced yet.
---
I shouldn't have been going down the path
of references. Learned my mistake here.
---
I'm taking a break.

@14:31 initial scaffolding for entity list #timelog:00:13:54
I've set things up in such a way that the only part in
the pipeline that is changing is what is happening
between line statements and the session map. With
any luck, I should be able to get a session map from this
new entity list.
---
The session map may need to be reworked to compensate for
connections to nodes, but the entity list should position
things in a good place for that because it'll allow easy
access to the last item, and more granular control over
what is being referenced.

@14:29 initial attempt implementing the scaffolding #timelog:00:35:27
