@2025-08-17#logzet
@14:33 Re-aquainting myself with this repo, hello logzet #logzet #timelog:00:05:25
I have this logging format that I have been using
for the past year or so. It's sort of adhoc, but
I have a few parsers for it. I'm hoping to make
a more established parser for it here. Similar
to dagzet, it'll parse files and return SQLite
code to produce relational databases.
---
I'm hoping to begin by adding a new aux binary
called logzet. I'd like to install it by default
with dagzet.
---
Well, that was pretty painless. Now for the harder
part, setting up the parser.

@14:42 Planning out the parser #timelog:00:17:31
For the most part, parsing is done line-by-line.
---
The start of the line determines what the line is
going to be.
---
An '@' at the start of the line
signifies the start of a block. What follows the @ determines
what kind of block it will be. For now, there are really two
types of blocks: blocks that indicate a date, and ones that
indicate a time.
---
Date Blocks: The format is YYYY-MM-DD?(#(TEXT)) (like my pseudo-regex?).
In the program, this thing sets the current day of the program.
The hashtag adds a tag for the day.
---
Time blocks: HH:MM (TITLE). This creates a log entry at a particular
time. A day block should be made before adding time. Everything following
the the timestamp (plus whitespace) is the title.
---
Titles in the time blocks can have hashtags. These do not get included in the
the actual title name, and should be automatically removed.


@15:20 continued parsing plans (describing the parser) #timelog:00:14:54
Lines that start with "#!" are logzet commands. Typically,
these come right after the line that starts a block,
but I don't think that needs to be the case.
---
The only command that is used currently is "dz", which
links the current log entry to a particular dagzet node.
---
A line that starts with '---', and nothing else, is considered
a break. Typically, I use these to break things into
paragraphs.
---
A line that starts with "===" begins a pre-formatted block, usually
used for code blocks. It preserve all line breaks and spaces until
it finds another lines starting with "===".
---
I think that's most of it?
---
OH! right. Empty lines are ignored.

@15:46 attack plan #timelog:00:31:06
I'm thinking I may have this be a two-pass parsing process.
The first pass tokenizes things by line, the second pass
parses these tokens to build up a more meaningful representation
of the data.
---
Tokenization is pretty straight forward. Use an enum.
Parse text line by line.
---
Plain text content in a block (anything that isn't a block
or metablock), can be stored line by line and merged later.
pre-formatted block starts change the behavior of the line
parser. Once a block starts, every line parsed after that
points becomes a preformatted line until it finds another
corresponding "===", which turns it off.
---
For logs, log entries are grouped by dates, and dates
can be grouped by category.
---
Claude has come up with suggestions for what to call
these things: A "Session" describes a combination of
a "Date" and an optional "Context". A Session contains
a group of log entries associated with that context.
---
Since dagzet support is also going to be wanted here,
there should be something that shows a list of
related nodes (represented as paths).
---
An Entry consists of a list of content chunks. Maybe
these are just called "blocks" (claude suggests this).
I want this log format to also be generalized in
terms of blocks, but that may be overgeneralizing.

@16:26 working out the initial data structures #timelog:00:47:38
I'm just gonna put them in the one file.
---
I'm thinking about source maps. I think the best way to
express this is as a generic struct that wraps
an inner type.
---
Got some initial structs down. Now, I want to create
some From traits for the lower-level statements.

@17:45 some initial From traits #timelog:00:11:12

@19:22 initial boilerplate: got "break" parsed #timelog:00:20:25

@19:43 attempting regex matching for Time #timelog:00:20:16
Ran out of time. Gotta get home.

@2025-08-18#logzet another hub session

@19:31 resuming where I left off, matches for Time #timelog:00:49:57
I got the basic regex working! now I need to add in
hashtags.

@20:21 Now a similar thing for Date #timelog:00:59:41
This will have a title. Might as well have hashtags?
This could be a generic.
---
Got the "context" hashtag working. Now getting the regular tags working?
---
Working!

@21:22 interlude... fix cargo clippy warnings #timelog:00:01:45

@21:25 get commands working #timelog:00:11:21

@22:07 next steps #timelog:00:10:12
There needs to be something that takes a list of
strings, and turns it into a corresponding vector
of Statements. This should be able to handle
comments as well as blocks.
---
A vector of statements, should also be able to be parsed
and turned into a set of sesssions.
---
Entries and sessions should be sorted. Use a BTreeSet?
Or possibly, it might be just good enough to use parsing
order?
---
Figure out best way to convert data into SQLite tables.
Figure out table schema, then make a bunch of insert
statements.
---
Dagzet commands. Get that behavior in.

@2025-08-19#logzet working at home, PLG, Brooklyn
@20:31 Let's see if I can plan out how Statements turn into Sessions #timelog:00:25:40
I've built myself function. Vector of Statements go in,
Vector of Sessions comes out.
---
I want the output list to be in chronological order.
I'm thinking order could be preservered internally with either
a BTreeMap or a BTreeSet, then converted to a Vec at the last minute.
---
The logic would work by keeping track of the last Date (year, month, day, context).
I believe that by default, the BTree will sort things in order that they appear
in the struct. subsequent statements, would then get processed and inserted into
that active slot.
---
Time entries, like Date entries, should be in sorted order as well. Having a BTree
would be nice, but the struct at the end should simplified to be a Vec somehow.
So, I guess there are some intermediates.
---
Two nested BTreeMaps. The Outer Map is for Dates, and each entry in that map
points to an Inner BTreeMap for Time Entries.
---
Date/Time structs need to be split up more because they have
junk in it like titles and tags. Maybe TimeKey and DateKey.
---
Build BTreeMap types for Session and Entry called SessionMap
and EntryMap. EntryMap is an alias for BTreeMap<TimeKey,Block>.
SessionMap is an alias for BTreeMap<DateKey,EntryMap>. Once it
is all populated, they can get converted to regular list of Sessions
which contain a regular list of entries.

@22:02 some initial refactoring to get DateKey and TimeKey #timelog:00:27:12
I also got the initial BTreeMaps set up as well. It
could be refactored further I think, but this is
good enough.

@22:30 First parse test: can days out of order be put in order? #timelog:00:39:25

@2025-08-20#logzet Brooklyn
@10:46 examining the existing SQLite code I have. Can I re-use it? #timelog:00:22:29
My SQLite generator code may be flexible enough to accomodate
the needs for my logs table.
---
My SQLite table code might just be flexible enough.
---
Reaquainting myself with the schemas now.
---
Right. I seem to have two parts to my SQLite interface.
There's a "Row", which contains data for a row. This
seems to exist to produce a comma separated set of values
in a specified order. There's a "Table", an opaque value which
gets dynamically constructed. This has the parameters as well
as their names. The Table and Row work together to create
insert statements.
---
Working with this interface, it seems like the path of
least resistance is to convert a list of Sessions
into a list of Rows that represent the SQLite table
representation. From there, the SQLite traits
can be built out.
---
I get the feeling that with a little bit more
work, I could maybe remove the intermediate
"Row" data format, but in many ways this is
simpler and less work since this is already
written out for me.

@11:18 building out a Row, an initial Session to Rows conversion #timelog:00:48:00
There are two kinds of rows actually, a "dayblurb" for the
day with a blurb (does this need to be there if blurb is none?)
and the entries themselves.
---
Working on the initial dayblurb because it's slightly less
work upfront.
---
Now to get some entries populated.

@12:38 continue to populate some entries for the test #timelog:00:18:07
I think I have the initial test set up. Now to implement
the actual code to make the entries

@12:56 implement the actual code to generate the entries #timelog:00:23:57
One thing that I've started doing more is having a single timelog
broken up into blocks. The current SQLite table doesn't
actually support blocks, that's something that gets handled
by the renderer. Moving forward, it would be better to have
this be modelled with the data.
---
For now, only comments will be supported, no preformatted stuff.
I never actually got around to implementing multi-comments
in my ad-hoc implementation. So, this'll mean breaking compatibility
eventually.
---
Tests seem to pass. Does that mean it works?

@13:41 more parser work for converting Statements into Sessions: grouping #timelog:01:03:23
Right, I'm going to work on getting the core logging components
figured out. That's going to be a date header, setting times,
and appending blocks to those times.
---
Going to make it really brittle right now. Overwriting
dates/times will be possible. I will harden later.
What I want to do is make sure the most bare minimum input
yields the correct output. At that point, the implementation
can start being more end to end.
---
dagzet commands will follow up shortly. I think I am going
to break backwards compatibility for this. I really
want more granular support for multiple blocks, and I want
to make it possible to link nodes to particular blocks
instead of just timestamps.
---
At this point, I'm going to assume the parsing is working
correctly? I think the observed behavior for this test
is that grouping is happening as expected for entries.
---
I didn't think about the line breaking logic. Line breaks
are treated as spaces. Empty lines are ignored.
---
Goodness time got away from me.

@15:04 I need to work out line breaking logic for this parser #timelog:00:33:40
Working backwards, I'm hoping this can be as simple as as
joining a vector of strings together.

@18:01 back to getting the grouping right #timelog:00:07:01
The line breaks work, I just didn't factor in the grouping.

@18:12 looking into dagzet logic #timelog:00:37:28
I think the way I did this before was a bit of a hack.
I believe what it did was was make the node a hashtag
with the prefix "dz:". I'd then have code that was able
to search for these nodes associated with messages
and stitch them up.
---
What I want is a more dedicated structure for the job.
Something that actually shows the relationship between
items.
---
Previously, I was only attaching nodes to entries. I'd
like to extend that to be with blocks inside an entry
as well. A more sophisticated command language would
be nice too, but I can think on that one later. Just
full paths and '$' should be good enough.
---
I could probably make an ID system work. The id would
map to a list of node paths. Somehow, this could be something
that could be query-able in a SQL join operation.
---
A potential structure could be an entity list. Anything
that gets made gets added to this list.
---
Any time you'd call the dagzet command, you'd be appending
it to the last entity item on the list.
---
This could be a helpful item in general for things like
source maps, so, I'm included to see how feasible it
would be to construct such a thing.

@18:59 entity list investigations, might need to go full ECS. Is this ECS? #timelog:00:23:48
For starters, get the old way working, which is
the ability to link to the entry. Build an entity
component list but only add entries.
---
Okay. So this might be a non-trivial refactor. I think
I need to reverse the thining. The entity list owns all
the components, and the struct just references it. This
is how an entity component system would work.

@20:12 let's try that entity list #timelog:01:49:07
I'm going timebox this, get some initial scaffolding in.
---
Huh, there's really just three entity types at the end of
the day: Sessions, Entries, and Blocks. Doesn't seem
so bad...
---
To try things out, I'm going to work on making all Blocks references,
and maintaing a list of blocks externally. This should get
the lifetime annotations correct. From there, I can more
generalize this list of blocks into a pool.
---
Okay, it started getting a little hairy there. I tried getting
blocks working for output data structure. But what if it was
for the intermediate data structure (BlockData)? This could
potentially be an internal refactor, might be less damage.
---
It has been an hour. I'm still running into similar borrow
checker woes. Once again, this feels like a dead end.
---
We could try fake pointers and a block arena.
---
Well, the block list works! A good proof of concept.
The way to extend this would be to turn this into
an entity Enum.
---
Okay, I made it a more generic list. It works, but I'm already
seeing the issues of indirection. Once more types get introduced,
everything just becomes vectors of pointers. Sigh.
---
Final thoughts: session "map" needs to be taken into another function
I think. Entity list might another intermediate step. commands might
be a part of the entity list? Statements -> Entities -> Entities + Maps with pointers -> Sessions
data struct (no references or entities), other linked metadata.

@2025-08-21 Brooklyn
@12:06 Back to solving the entity list problem, first restating the problem #timelog:00:13:54
I am opting for a different structure than what currently exists.
The restructuring is going to be needed because it will make it
easier to tie content into dagzet.
---
The restructuring involves building an entity list, where every
possible type of item a log can make lives. Currently that's
Session (a day plus context), Entry (a timestamped log entry in a Session),
and a Block (something attached to an entry, usually text).
The existing structure (a struct outling the tree-structure hierarchy
of the session->entry->block relationships), would be refactored to
link to references from the entity list.
---
The reason why this way is ideal: it would allow building structures
that can easily link entities (referenced by an entity ID) to
groups of nodes. I want to extend the functionality of this linking
system beyond the original implementation I had to make it possible
to not only link to entries, but individual blocks as well.
---
The trouble is, how do we get this to work in such a way that
the borrow checker likes this. Right now, I am testing things
out by making blocks tracked externally. I managed to get fake
pointers working, but this is subpar because types will go away
with that approach, it's all just usizes.
---
I want to try and separate out the construction of the intermediate
data format, which I use to sort out the timestamps for sessions
and entries. Maybe with the right encapsulation I can please the
borrow checker? It's mostly been mutability issues. My lifetime
annotations have been no problem.

@12:23 pulling out sessionmap #timelog:00:07:26
This actually is helpful because it builds an abstraction
barrier of immutability. This new function returns a session
map and an entity list, both of which are immutable by the
time they leave the function. In a way, the Rust Compiler
is forcing us to build these abstractions. Probably a good
thing?

@12:34 now we fight the borrow checker. get blocks to be references #timelog:00:12:19
I get the feeling there might be a trick to this.
---
Here come the lifetime annotations.
---
Okay, the red squigglys are here. The problem has to do with
the way blocks are getting populated with lines. There seems
to be too many "access lines". The way parsing happens is,
text lines are always appended to the last created block.
The way this block is being accessed is through the last
created entity, but this only has a read-only reference.
This should probably be only done via the entity list.
---
Well, I commented out some things. It builds, but some
tests fail. As expected.

@13:11 trying to build an EntityListBuilder #timelog:00:35:41
This will be an interface that can populate a list of entities,
and at the end, I can return a immutable reference
to the list built. Should hopefully encapsulate some of the
mutabiliy issues
---
all write operations will be done through this
interface, instead of indirectly through the
last created entity. It's already assumed that
the last block made will be tied to the last
entity.
---
Sure enough, the moment I add things that return references,
I run into lifetime issues. I think I might
need to encapsulate the session map.
---
I have encapsulated the session map, which hopefully means
later I can move some logic inside the struct methods.
I've added some TODOs. In the meantime, gotta go.

@2025-08-22#logzet Brooklyn, PLG
@11:20 continued work on EntityListBuilder #timelog:01:31:57
I feel like I'm on the right path with encapsulation.
This seems to please the borrow checker.
---
...except some tests aren't passing. I thought I got
that working yesterday. Hmm...
---
looks like the grouping logic is broken.
---
right, I didn't actually implement the methods
for appending stuff to blocks and creating
new blocks.
---
Running into lifetime issues trying to append
the reference to the block to the entry.
---
I'm wondering if I need to group the session
map and the entity list into a struct.
---
I've merged the two things into a struct,
and I'm still getting lifetime issues.
---
There are too many mutable sources. the session
map and entity list can't both be mutable.
---
Can we build a session map, with references, from a read-only
entity list?
---
Or maybe, there's a sort of thing where we use a builder
pattern that appends items to the session map, but the
write is encapsulated in a method.
---
Yeah, that's not going to work either.
---
I'm trying the Statements -> Entities -> SessionData -> Session route,
where the new thing is explicitly making the entities,
THEN making the session data.
---
I'm going back a bit further now. The entity list initial
attempt was flawed from the start.

@12:57 Make entity list an initial intermediate format. NEVERMIND. #timelog:00:29:57
Blow up more old entity list
---
Now to think about this entity list a bit.
---
Entities are something inbetween statements
and the full-on data representations. No
nesting relationships are produced yet.
---
I shouldn't have been going down the path
of references. Learned my mistake here.
---
I'm taking a break.

@14:31 initial scaffolding for entity list #timelog:00:13:54
I've set things up in such a way that the only part in
the pipeline that is changing is what is happening
between line statements and the session map. With
any luck, I should be able to get a session map from this
new entity list.
---
The session map may need to be reworked to compensate for
connections to nodes, but the entity list should position
things in a good place for that because it'll allow easy
access to the last item, and more granular control over
what is being referenced.

@14:29 initial attempt implementing the scaffolding #timelog:00:35:27

@15:07 phew! finally, think about connection to dagzet nodes #timelog:01:07:16
All entities need UUIDs.
---
Map the UUIDs to list of nodepaths.
---
The DZ command is processed with the entity list is being
created.
---
All entities need to have an id now. Enforce this with
traits.
---
WithId trait implemented. DZ commands should work for entries and blocks.

@16:56 I gotta think how this is going to work with SQL tables #timelog:01:01:58
The schemas are going to need to be adjusted
---
Big change is going to be that comment blocks will need to be in their
own table I think. It's possible in the future we mave more kinds
of blocks, but right now it's just comments. sometimes they are
preformatted with line breaks. But the row is going to be identical by the time
it hits SQLite.
---
Later, it might be a good idea to have an entity list table that maps ID values
to entity types for a type lookup. But, in practice, I don't think that sort
of thing is going to be needed for queries (yet).
---
I think an entity table might actually be necessary if I want to append logs to an
existing database like I do with dagzet and dz_nodes.
---
actually, dagzet just inserts the ids as-is without any kind of offset calculation
in the SQLite query (at least, from what I can see). It *is* able to do
id resolution from a path.
---
Am I really just generating my knowledge graph by cramming a shitton of
arguments on the commandline?
---
oh, I see. yeah, my node list has ID values auto-generated from SQLite,
but "position" is a value that gets inserted which I was confusing for
node id. Well, that makes things more interesting.
---
Might need to make the id a string like a timestamp or something. There
are definitely ways to make unique identifiers.
---
YYYY-MM-DD-(CONTEXT)-HH-MM-(CONTEXT)-POS I think is all that's needed.
If you don't supply a unique context, logs can overwrite eachother, but
I think that's fine
---
YYYY-MM-DD-ABCDEFG-HH-MM-ABCDEFG-0FF
---
38322B65-1651-4272-8490-93557971EF6B
---
For context, for the same size of a UUID,
you can have a session AND time with a unique
context tag of 7 characters, and the session can
have 4095 blocks associated with it when position
is encoded in base16 (12-bit number). So, this
might be a perfectly reasonable persistent UUID.

@19:39 More Log UUID thoughts #timelog:00:19:44
Rearticulating the idea.
---
A set of logs are made up of smaller components called entities.
---
Entities connect to eachother in a way that forms a hierarchy
between "Sessions" (a day), "Entries" (times of day), and
"Blocks" (text content that is associated with an entry).
---
Entities can also be connected to dagzet nodes.
---
Different entities have different kind of metadata. In SQL,
the data for the entities gets broken up into tables.
---
These metadata tables need to be able to know which entity
it belongs to. In Dagzet, tables are linked together with
foreign ids, which point back to a master node list.
---
To mirror the dagzet pattern there would need to be an entity
list. Each entity gets an auto assigned row id, as well as
a unique identifier. This row id is what is actually used
as the id (integers are smaller, faster than strings).
The SQLite queries generated use this unique identifier to
look up what the row id is.
---
Thinking the format of this UUID should be YYYY-MM-DD?(-CONTEXT1)/HH-MM?(-CONTEXT2)/POS.
It follws the same path logic as the dagzet nodes. Sessions would only
get the first part of the path, entries would get the first 2 parts,
and blocks would get all three parts.
---
Note that UUID is only required for the SQLite table.
It's not necessary for the intermediate logic. local IDs work just fine.

@19:59 fix up broken test #timelog:00:04:22
I'm changing SessionRows and LogRow.

@20:05 Entity UUIDs for SessionRows #timelog:00:59:20
SessionRows are made from a Session, and the
conversion happens via a From trait.
---
Renaming structs to be more consistent with
my terminology. Previously, I was trying to work
towards an existing schema I was working with. Now,
I think it's more worthwhile to just start over.
This will be better, and it's worth the burn.
The SQLite databases are temporary. The source of truth
are the logs, and those will still work.
---
focusing on getting the entity UUIDs right now.
---
Entity UUIDs work as expected for Sessions and entries. Now I need
to extend it for blocks.
---
Can we make RowEntries embed RowBlocks. What's to stop us from doing that?
Not terribly important for now, but maybe food for thought later.
---
Entries UUIDs work for Sessions, Entries, and Blocks. Seeing
how they look in the tests, it actually looks pretty clean.
I think this is going to be a very helpful format.

@21:06 Configuring the connection table is next #timelog:00:40:20
I added connection rows to SessionRows, but Session
doesn't have the information for connections? Where
am I storing that information?
---
Ah. It's in the entity list. I have not yet decided on how
to get these connections exposed to the Session. Entity IDs
get erased currently.
---
You can make From traits for tuples? Okay that's sick. I can
use that to make a Session from a SessionMap and a DateKey.
---
The from traits make the whole SessionMap -> Session much
easier to read.
---
Oh, I see some complications. If you can connect a node to
the entire session (this is technically possible), you can't
exactly put the connection list inside of a Session as a child.
It needs to exist alongside the Session, so it lives alongside
the session list.
---
So, I got a few structs up. Basically, I want to see if it's possible
to store the list of sessions, and then a list of connections with
a pointer to the entity it belongs to (which could exist in any
of the sessions).
---
Okay, gotta stop. Bed now.

@2025-08-23#logzet Brookln, PLG
A day at the Met. Now, I am post dinner, post dessert, and
post late afternoon caffeinated. Let's see what I can do today.

@19:02 initial attempt at building out a connections list #timelog:00:52:41
There *is* a connections list. It is contained in the
EntityList. It is a map that ties entity id to a list
of dznode paths (strings). I would like to turn this
into a list of things with the dz node path and
the direct reference to that thing.
---
References are hard. I'm going to try a small test.
Can I locally populate a list of references of a particular
type? And if so, can I create a function that generates that
list from a session map?
---
Think I might be just stroking Rust the wrong way. I'm already
running into issues.
---
Claude seems to think I can use hash_map.values().collect()
to make read-only list of referenced values. Let's see if that
actually works.
---
It works! A little clue. But, this is tricky because the items
are nested, so only the sessions appear. We need a flat list.

@19:56 I think I may need a new Session Tree structure #timelog:00:24:25
Basically, the session tree can only made up of references from
the entity list. Maybe just have things made up of indices
from the entity list.
---
Okay. This is the new plan. logzet stuff needs to get moved out of the binary
and broken up into individual files. It is time. I think this code
is officially hard to work through in one place.

@20:23 clean up logzet, put it in a module in the library #timelog:00:49:35
also split up the module into different components
---
I have created a lib.rs file with the logzet stuff as a module, and
that file is being used in the binary called logzet.
---
now to move things.
---
statement.rs
---
entity.rs
---
session.rs: WAY too many imports. clearly need to abstract this
one better. Probably should pull some of this into the top-level
mod.rs function.
---
rows.rs
---
id.rs

@21:54 What's next: the session as a tree of links #timelog:00:14:06
A "Session" can be thought of a tree structure. A session
is composed of Entries, and Entries are composed of Blocks.
---
Our current Session has these data items nested directly.
However, this becomes tricky when any of these components
can link to a list of nodes. So, the idea is to use the
genertated EntityList more directly, and have the Session
be composed of virtual pointers to this EntityList.
---
"virtual pointers" in Rust are just indices, which are
just usize types. I want these indices to be typed
so it's not just a bunch of usizes flying
around.

@2025-08-24#logzet Brooklyn, PLG
@08:35 initial session tree scaffolding #timelog:00:29:05
Going to need typed entity indices. ended up just
making them struct tuples.
---
Added some getters that take in these typed indices
---
fleshing out the session tree struct. This is going
to look a lot like our current session struct, but
with references.
---
Thing I'm going to make a SessionMapBuilder, that
can be generic over either a SessionMap or a SessionTreeMap.

@09:05 Session builder? #timelog:01:53:18
I started coding too quickly. Resetting.
---
Initial SessionBuilder created, no generics.
---
Thinking through how to make things more generic. Generic
enough for the session tree
---
It's helpful to organize, I guess. It's helping me realize
that this might be another dead end, or that I'm further
from my refactoring goals than I expected. How are the indices
going to get inserted?
---
in entities_to_session_map, the entity ID is the index in
the entity list. So, when items are passed into the insert
methods, the id should be passed in as well. This can
be paired with the `with_id` trait I think. With the
current session map stuff, this won't do anything. With
the session tree, it will actually set the indice.
---
ID values have been introduced into the interface. ID data from
the entity list gets proliferated into deeper the system, and if I'm
thinking about it right, it should touch the parts where the actual
tree nodes would be constructed.
---
I now need to direct my attention to traits again. Bottoms up.
Deal with the smaller traits, encapsulate, then work upwards to
the session builder.
---
The lowest level concern is the thing in charge of appending
blocks to an entry. Some kind of method or trait called "append_block"?
---
Or, maybe, just maybe. EntryData is generic over a type?
---
EntryNode and EntryData are so close. But, I think it might
rip up too many things to change EntryData.
---
Trying to top-down this thing and let the compiler tell
me what needs to be finished.
---
My type aliases EntryMap and SessionMap need to go. They
need to be broken down into the BTreeMap KV components. The
key stays the same, the value will change.
---
Managed to barely make EntryData generic.
---
Managed to barely make SessionData generic.

@11:07 continuing with the refactor #timelog:00:48:16
Going to bottoms-up Session Builder with generics.
Make sure it can be generic over blocks, then entries,
then sessions.
---
Okay, that wasn't great. Perhaps it wasn't the best idea
to hop abstractions from BlockData to SessionMap. It
should be completely encapsulated at this point anyways.
---
Going to stab it top down. Make SessionData an alias,
then try to worm that into a generic.
---
Used a phantom data type to make the outer layer generic
syntax work as expected. Had to remove the Default
trait and replace it with an explicit new method,
but that's okay.
---
Now, time to see what breaks when T is actually used.

@12:00 failed again. maybe SessionBuilder needs better encapsulation? #timelog:00:15:00
The methods here have leaky abstractions, which may be
contributing to my poor attempts at refactoring.
---
Maybe use the "inner" pattern. wrap these BTreeMaps into structs,
and add getter methods for those.
---
Well, certainly EntryMap for starters, working bottoms-up.
---
Okay, insert method for EntryMap feels like a nice win.

@12:27 more inner encapsulation #timelog:00:45:53
This block insertion business is drilling down too deep.
---
I still haven't figured out the block encapsulation yet,
but I got session map encapsulated now. Eventually,
block insertion will be encapsulated in an entry,
entry insertion will be encapsulated in session. block
insertion possible from the session maybe? does that
make life better or worse?
---
Got a generic partially working for EntryMap. Should
be fully generic for EntryMap downwards, hardcoded to
BlockData for SessionMap.

@13:24 back to trying to make it generic from top-level #timelog:00:15:00
Let's see what breaks
---
Things need to bubble up more. Blocks need to be inserted
from entries, entries need to be inserted from sessions.
---
Well, that's all the time we have for now. Damn.

@16:38 some traits built on SessionData #timelog:00:31:17
I managed to get insert_entry as a method in the SessionData
struct. But, I think this is going to need to be a trait.
---
Oh my god. This trait issue that was grinding me was a really
easy fix. I was just putting the "where" syntax in the wrong place.
---
Now, do the same for appending a block. Make it a method,
for SessionData then a trait implemented for SessionData.

@17:10 Yet another attempt at generiszing the top-level SessionBuilder
ADD 15
---
Let's see what breaks. Hopefully it's a bit less.
---
insert block behavior requires another trait parameter,
can that be removed?
---
It doesn't look like it. BlockData needs to be an actual argument
passed in at the top-level interface.
---
Still pain points with From<Time>.
---
Actually, the pain point is with BlockData. Isn't it always going
to be BlockData? That comes directly from the entity list. I don't
need to make a separate trait for it.
---
I think we did it? I think it's generic?
